#

I want to review the findings [07](/findings/07.md).

The identified root cause is the following function:

```rust
pub async fn get_env_input_for_l1_inclusion_and_l2_block_number(
    chain_id: u64, // chain_id=ethereum
    is_sepolia: bool, // false
    l1_inclusion: bool, // true
    ethereum_block: Option<u64>,
    fallback: bool,
) -> (Option<EvmInput<EthEvmFactory>>, Option<u64>) {
    if !l1_inclusion {
        // If L1 inclusion is not required, return None for both values
        (None, None)
    } else {
        // ...

        // Delegate to the appropriate helper based on chain type
        if is_opstack_chain(chain_id) {
            // ...
        } else if is_linea_chain(chain_id) {
            // ...
        } else {
            // This is the root cause
            panic!(
                "L1 Inclusion only supported for Optimism, Base, Linea and their Sepolia variants"
            );
        }
    }
}
```

lets trace backwards:

```rust
pub async fn get_proof_data_zkvm_input(
    users: Vec<Address>,
    markets: Vec<Address>,
    target_chain_ids: Vec<u64>,
    chain_id: u64, // chain_id=ethereum
    l1_inclusion: bool, // l1_inclusion=true
    fallback: bool,
) -> Vec<u8> {
    // ...

    let (block, commitment, block_2, commitment_2) =
        get_sequencer_commitments_and_blocks(
            chain_id,
            rpc_url,
            is_sepolia,
            l1_inclusion,
            fallback,
        )
        .await;

    let (
        l1_block_call_input_1,
        ethereum_block_1,
        l1_block_call_input_2,
        _ethereum_block_2,
    ) = get_l1block_call_inputs_and_l1_block_numbers(
        chain_id,
        is_sepolia,
        l1_inclusion,
        block,
        block_2,
        fallback,
    )
    .await;

    let (env_input_l1_inclusion, l2_block_number_on_l1) =
        get_env_input_for_l1_inclusion_and_l2_block_number(
            chain_id,
            is_sepolia,
            l1_inclusion,
            ethereum_block_1,
            fallback,
        )
        .await;

    let block = if l1_inclusion && is_linea_chain(chain_id) {
        l2_block_number_on_l1.unwrap()
    } else if is_ethereum_chain(chain_id)
        || (is_opstack_chain(chain_id) && l1_inclusion)
    {
        ethereum_block_1.unwrap()
    } else {
        block.unwrap()
    };

    let (chaind_id_linking_blocks, rpc_url_linking_blocks) =
        if is_opstack_chain(chain_id) && l1_inclusion {
            let (ethereum_chain_id, is_ethereum_testnet) =
                if matches!(chain_id, OPTIMISM_CHAIN_ID | BASE_CHAIN_ID) {
                    (ETHEREUM_CHAIN_ID, false)
                } else {
                    (ETHEREUM_SEPOLIA_CHAIN_ID, true)
                };
            (
                ethereum_chain_id,
                get_rpc_url("ETHEREUM", fallback, is_ethereum_testnet),
            )
        } else {
            (chain_id, rpc_url)
        };

    let (linking_blocks, (proof_data_call_input, proof_data_call_input_op)) = tokio::join!(
        get_linking_blocks(
            chaind_id_linking_blocks,
            rpc_url_linking_blocks,
            block
        ),
        get_proof_data_call_input(
            chain_id,
            rpc_url,
            block,
            users.clone(),
            markets.clone(),
            target_chain_ids.clone(),
            l1_inclusion,
            fallback,
        )
    );

    let input: Vec<u8> = bytemuck::pod_collect_to_vec(
        &risc0_zkvm::serde::to_vec(&(
            &proof_data_call_input,
            &chain_id,
            &users,
            &markets,
            &target_chain_ids,
            &commitment,
            &l1_block_call_input_1,
            &linking_blocks,
            &env_input_l1_inclusion,
            &proof_data_call_input_op,
            &commitment_2,
            &l1_block_call_input_2,
        ))
        .unwrap(),
    );

    input
}
```

okay my assumption is correct, its called with `chain_id=1` and
`l1_inclusion=true`.

I wonder wether we can found similar bug in adjacent functions.

Lets write some unit test to verify it.
