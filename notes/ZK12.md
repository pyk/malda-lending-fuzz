# How linea block header is verified?

> The ZK Coprocessor must verify that any Linea block header used in a
> `l1_inclusion=false` proof is signed by the canonical Linea sequencer.

it uses `validate_linea_env` function

```rust
pub fn validate_linea_env(
    chain_id: u64,
    block_header_to_validate: &RlpHeader<Header>,
)
```

it requires `block_header_to_validate` where this come from, lets trace back to
the source.

in the `get_validated_block_hash_linea` the function called

```rust
pub fn get_validated_block_hash_linea(
    // ...
    block_header_to_validate: RlpHeader<Header>,
    // ...
) -> B256 {
    if validate_l1_inclusion {
		    // ...
    }
    // Always validate the Linea environment (signature check).
    validate_linea_env(chain_id, &block_header_to_validate);
    block_header_to_validate.hash_slow()
}

```

tets find the source of `block_header_to_validate` .

`get_validated_block_hash_linea` is called by `get_validated_block_hash`

```rust
pub fn get_validated_block_hash(
    // ...
    block_header_to_validate: RlpHeader<Header>,
    // ...
) -> B256 {
    // Dispatch to the correct validation logic based on chain type.
    if chain_id == LINEA_CHAIN_ID || chain_id == LINEA_SEPOLIA_CHAIN_ID {
        get_validated_block_hash_linea(
            // ...
            block_header_to_validate,
            // ...
        )
		}
```

`get_validated_block_hash` is called by `validate_get_proof_data_call`

```rust
pub fn validate_get_proof_data_call(
    chain_id: u64,
    account: Vec<Address>,
    asset: Vec<Address>,
    target_chain_ids: Vec<u64>,
    env_input_for_viewcall: Option<EthEvmInput>,
    sequencer_commitment_opstack: Option<SequencerCommitment>,
    env_input_opstack_for_l1_block_call: Option<EthEvmInput>,
    linking_blocks: &Vec<RlpHeader<Header>>,
    output: &mut Vec<Bytes>,
    env_input_eth_for_l1_inclusion: &Option<EthEvmInput>,
    env_input_opstack_for_viewcall_with_l1_inclusion: Option<OpEvmInput>,
    sequencer_commitment_opstack_2: Option<SequencerCommitment>,
    env_input_opstack_for_l1_block_call_2: Option<EthEvmInput>,
) {
    // Sort and verify all relevant parameters for the proof data call,
    // including environment and block headers.
    let (
        // ...
        block_header_to_validate,
        // ...
    ) = sort_and_verify_relevant_params(
        chain_id,
        env_input_for_viewcall,
        linking_blocks,
        env_input_eth_for_l1_inclusion,
        env_input_opstack_for_viewcall_with_l1_inclusion,
    );

    // Validate the block hash for the given chain and environment.
    let validated_block_hash = get_validated_block_hash(
        // ...
        block_header_to_validate,
        // ...
    );

```

`block_header_to_validate` is from `sort_and_verify_relevant_params`

```rust
pub fn sort_and_verify_relevant_params(
    chain_id: u64, // Linea Chain
    env_input_for_viewcall: Option<EthEvmInput>,
    linking_blocks: &Vec<RlpHeader<Header>>,
    env_input_eth_for_l1_inclusion: &Option<EthEvmInput>, // None
    env_input_opstack_for_viewcall_with_l1_inclusion: Option<OpEvmInput>, // None
) -> (
    // ...
    RlpHeader<Header>,
    // ...
) {
    // ...
    } else {
        // For L1 or Linea chains, use the provided environment input.
        let chain_spec = match chain_id {
            LINEA_CHAIN_ID => &LINEA_MAINNET_CHAIN_SPEC,
            LINEA_SEPOLIA_CHAIN_ID => &LINEA_MAINNET_CHAIN_SPEC,
            _ => &ETH_MAINNET_CHAIN_SPEC,
        };

        (
            env_input_for_viewcall
                .expect("env_input is None")
                .into_env(&chain_spec),
            None,
            None,
            chain_id,
        )
    };

    // Select the block header to validate: use the last linking block if
    // present, otherwise use the environment's header.
    let block_header_to_validate = if linking_blocks.is_empty() {
		    // Fetch linea latest block
        env_for_viewcall.header().inner().clone()
    } else {
        linking_blocks[linking_blocks.len() - 1].clone()
    };

		 // ...

    (
        // ...
        block_header_to_validate,
        // ...
    )
}

```

- The `block_header_to_validate` source is either from Linea RPC latest block or
  `linking_blocks`.
- `validate_linea_env` panic if `sequencer != expected_sequencer`
