# Incorrect Assertion in Dispute Game Commitment Validation

The
[`validate_opstack_dispute_game_commitment`](https://github.com/sherlock-audit/2025-07-malda-pyk/blob/51c3a8231a37b622235151254a21cebbc1fa78e1/malda-zk-coprocessor/malda_utils/src/validators.rs#L291)
function is used to validate the OP Dispute Game Validation, it guarantee that
it will panics if insufficient time has passed since game resolution. However,
the actual implementation allows dispute game commitment to pass even tho the
resolution time is not sufficient.

## Root Cause

Here is step by step on how the Malda ZK Coprocessor validate the game
commitment:

1. Decodes the L2 State Commitment
2. Verifies the game type and creation time
3. It asserts that the defender must wins
4. It checks blacklisting
5. It checks the finality
6. It make sures that the `root_claim` match

Now, lets focus on the step 5. The current implementation is trying to add some
time buffer, this can be used to protects against L1 reorgs affecting the game's
final outcome.

```rust
let current_timestamp = eth_env.header().inner().inner().timestamp;
assert!(
    U256::from(current_timestamp) - U256::from(resolved_at)
        > proof_maturity_delay - U256::from(300),
    "insufficient time passed since game resolution"
);
```

The assertion can be written as:

```rust
current_timestamp - resolved_at > delay - 300
```

However, if you look closely this time buffer is the source of bug. We can
simplify the assertion as follows:

```rust
current_timestamp - resolved_at + 300 > delay
```

This means the code allows the validation to pass even if the full `delay` has
not yet elapsed, as long as it is within the last 5 minutes of the waiting
period.

## Internal Pre-conditions

No internal pre-conditions are required.

## External Pre-conditions

No external pre-conditions are required.

## Attack Path

This is not an attack.

## Impact

The validation logic for L1 inclusion for the OP stack is broken.

## PoC

N/A

## Migitigation

N/A
