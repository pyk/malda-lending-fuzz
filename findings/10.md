# ZK Coprocessor Incorrectly Use Sequencer Commitment for Ethereum L1

## Summary

The security of Ethereum L1 operations in Malda ZK Coprocessor is reduced to the
security of the Optimism L2 sequencer. This fundamentally inverts the L1-L2
trust model.

## Root Cause

Lets review how the expected chain verification works based on the
[docs](https://github.com/sherlock-audit/2025-07-malda-pyk/blob/51c3a8231a37b622235151254a21cebbc1fa78e1/malda-zk-coprocessor/README.md?plain=1#L73C1-L88C31):

1. **Ethereum (L1)**
   - Light client verification through beacon chain
   - Proof state via OPstack L1 reads

2. **Optimism/Base (OpStack)**
   - Sequencer commitment verification
   - Dispute game validation
   - L1 block inclusion proofs

3. **Linea**
   - Sequencer commitment verification
   - L1 block inclusion proofs

It's expected that ZK Coprocessor only uses Sequencer commitment verification
for L2.

Next, Lets see how it is actually implemented.

Focus on the Host program. The critical code path is in the
`malda-zk-coprocessor/malda_rs/src/viewcalls.rs`:

```rust
pub async fn get_proof_data_zkvm_input(
    users: Vec<Address>,
    markets: Vec<Address>,
    target_chain_ids: Vec<u64>,
    chain_id: u64,
    l1_inclusion: bool,
    fallback: bool,
) -> Vec<u8> {
    // ...

    let (block, commitment, block_2, commitment_2) =
        get_sequencer_commitments_and_blocks(chain_id, rpc_url, is_sepolia, l1_inclusion, fallback)
            .await;

    // Prepare L1 block call inputs and block numbers if needed
    let (l1_block_call_input_1, ethereum_block_1, l1_block_call_input_2, _ethereum_block_2) =
        get_l1block_call_inputs_and_l1_block_numbers(
            chain_id,
            // ...
        )
        .await;

    // @audit ethereum_block_1 here is from optimism even tho chain_id=1

    // Prepare environment input for L1 inclusion and L2 block number
    let (env_input_l1_inclusion, l2_block_number_on_l1) =
        get_env_input_for_l1_inclusion_and_l2_block_number(
            chain_id,
            is_sepolia,
            l1_inclusion,
            ethereum_block_1,
            fallback,
        )
        .await;

    // Determine the block number to use for linking blocks and proof data call input
    let block = if l1_inclusion && is_linea_chain(chain_id) {
        l2_block_number_on_l1.unwrap()
    } else if is_ethereum_chain(chain_id) || (is_opstack_chain(chain_id) && l1_inclusion) {
        // @audit Then it used here
        ethereum_block_1.unwrap()
    } else {
        block.unwrap()
    };

    // ...

    input
}
```

As you can see, when `chain_id=ETHEREUM_CHAIN_ID` it calls
`get_sequencer_commitments_and_blocks` and
`get_l1block_call_inputs_and_l1_block_numbers` which then used as `block` and
used as subsquent executions.

Finally, lets see how this data is used on the Guest program.

The critical code path is in
`malda-zk-coprocessor/malda_utils/src/validators.rs`:

```rust
pub fn get_validated_block_hash(
    chain_id: u64,
    env_header_to_validate: Header,
    sequencer_commitment_opstack: Option<SequencerCommitment>,
    env_input_opstack_for_l1_block_call: Option<EthEvmInput>,
    env_input_eth_for_l1_inclusion: &Option<EthEvmInput>,
    block_header_to_validate: RlpHeader<Header>,
    validate_l1_inclusion: bool,
    op_env_commitment: Option<&Commitment>,
    sequencer_commitment_opstack_2: Option<SequencerCommitment>,
    env_input_opstack_for_l1_block_call_2: Option<EthEvmInput>,
) -> B256 {
    // Dispatch to the correct validation logic based on chain type.
    if chain_id == LINEA_CHAIN_ID || chain_id == LINEA_SEPOLIA_CHAIN_ID {
        // ...
    } else if chain_id == OPTIMISM_CHAIN_ID
        || chain_id == BASE_CHAIN_ID
        || chain_id == BASE_SEPOLIA_CHAIN_ID
        || chain_id == OPTIMISM_SEPOLIA_CHAIN_ID
    {
        // ...
    } else if chain_id == ETHEREUM_CHAIN_ID || chain_id == ETHEREUM_SEPOLIA_CHAIN_ID {
        get_validated_ethereum_block_hash_via_opstack(
            sequencer_commitment_opstack.as_ref(),
            env_input_opstack_for_l1_block_call,
            chain_id,
            sequencer_commitment_opstack_2.as_ref(),
            env_input_opstack_for_l1_block_call_2,
        )
    } else {
        panic!("invalid chain id");
    }
}
```

As you might have noticed, its literally calls
`get_validated_ethereum_block_hash_via_opstack` which I believe this is the
completes inversion of the security model.

## Internal Pre-conditions

No internal pre-conditions are required.

## External Pre-conditions

No external pre-conditions are required.

## Attack Path

This is not an attack.

## Impact

I believe the first highest impact that I can think of is critical security
downgrade. The security of Ethereum L1 operations is reduced to the security of
the Optimism L2 sequencer.

Second highest impact is the uptime. Liveness of the protocol on Ethereum
becomes dependent on the liveness of the Optimism sequencer. If the Optimism
sequencer halts, no new proofs can be generated for Ethereum, halting halting
all cross chain operations for Ethereum which should have the highest uptime
among all extension chains.

## PoC

None

## Migtigation

None
