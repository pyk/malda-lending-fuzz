# The self-sequencing mechanism is broken for transactions originating from Ethereum

Malda allows users to perform self-sequencing. For the generated `journalData`
and `seal` to be accepted by the on-chain contracts, the user must set
`l1_inclusion=true`. However, when a user attempts to self-sequencing from
Ethereum for use on Linea with `l1_inclusion=true`, the ZK Coprocessor will
always panic, preventing the user from generating the required proof.

## Root Cause

Here is the step-by-step process for how the current implementation is supposed
to generate a proof for a user's deposit on Ethereum:

1.  The user sets up the required environment variables.
2.  The user calls `get_proof_data_prove` in the Malda SDK to generate a local
    proof.
3.  The SDK prepares the necessary ZK EVM input by fetching and validating
    on-chain data.
4.  The SDK packages all inputs required by the guest program into a single byte
    array.
5.  The SDK executes the guest program using these packaged bytes to produce the
    final proof.

The critical failure happen in step 3. If we look closely at how the Malda SDK
prepares the ZK EVM input, we can trace the exact point of failure.

The process begins in `get_proof_data_prove`, which calls `get_proof_data_env`
to gather all necessary data:

```rust
pub async fn get_proof_data_prove(
    // ...
) -> Result<ProveInfo, Error> {
    let prove_info = tokio::task::spawn_blocking(move || {
        // ...
        let env = rt.block_on(get_proof_data_env( // <-- HERE
            users,
            markets,
            target_chain_ids,
            chain_ids,
            l1_inclusion,
            fallback,
        ));
        // ...
    })
    .await?;

    prove_info
}
```

Next, `get_proof_data_env` spawns asynchronous tasks that call
`get_proof_data_zkvm_input` for each chain:

```rust
async fn get_proof_data_env(
    // ...
) -> ExecutorEnv<'static> {
    // ...
    let futures: Vec<_> = (0..chain_ids.len())
        .map(|i| {
            // ...
            tokio::spawn(async move {
                get_proof_data_zkvm_input( // <-- HERE
                    users,
                    markets,
                    target_chain_id,
                    chain_id,
                    l1_inclusion,
                    fallback,
                )
                .await
            })
        })
        .collect();
    // ...
}
```

Finally, `get_proof_data_zkvm_input` calls several helpers, including the
function where the panic is triggered:
`get_env_input_for_l1_inclusion_and_l2_block_number`.

```rust
pub async fn get_env_input_for_l1_inclusion_and_l2_block_number(
    chain_id: u64,
    // ...
) -> (Option<EvmInput<EthEvmFactory>>, Option<u64>) {
    if !l1_inclusion {
        // ...
    } else {
        // ...
        if is_opstack_chain(chain_id) {
            // ...
        } else if is_linea_chain(chain_id) {
            // ...
        } else {
            // THIS PANIC IS ALWAYS TRIGGERED FOR ETHEREUM
            panic!(
                "L1 Inclusion only supported for Optimism, Base, Linea and their Sepolia variants"
            );
        }
    }
}
```

The logic in this final function is the root cause. When a user tries to
self-sequence from Ethereum (`chain_id=1`) and sets `l1_inclusion=true`, as
required by the onchain contracts, the function's control flow hits a dead end.
The conditions `is_opstack_chain(1)` and `is_linea_chain(1)` both evaluate to
`false`. This forces the execution into the final `else` block, which
unconditionally triggers the panic.

## Internal Pre-conditions

No internal pre-conditions are required.

## External Pre-conditions

No external pre-conditions are required.

## Attack Path

This is not an attack.

## Impact

It completely breaks a core self-sequencing feature described in the
architecture.

## PoC

N/A

## Migitigation

N/A
