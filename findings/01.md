# Incorrect Access Control in withdrawGasFees

## Summary

The contest README state that:

> Sequencer is semi-trusted - It is trusted to maintain volume control and
> monitor the underlying chains for security. **It can only execute UserOps
> based on zkProofs.**

However, the incorrect access control on the `withdrawGasFees` allows squencer
to also withdraw the collected gas fees.

## Root Cause

In
[src/mToken/extension/mTokenGateway.sol](https://github.com/sherlock-audit/2025-07-malda-pyk/blob/main/malda-lending/src/mToken/extension/mTokenGateway.sol#L194),
the `withdrawGasFees` function allows an address with the `SEQUENCER` role to
withdraw the contract's entire ETH balance.

```solidity
function withdrawGasFees(address payable receiver) external {
    if (msg.sender != owner() && !_isAllowedFor(msg.sender, _getSequencerRole())) {
        revert mTokenGateway_CallerNotAllowed();
    }
    uint256 balance = address(this).balance;
    receiver.transfer(balance);
}
```

This implementation contradicts the documented trust assumptions in the contest
README, which defines the Sequencer as a semi-trusted role with limited
capabilities:

> Sequencer is semi-trusted - It is trusted to maintain volume control and
> monitor the underlying chains for security. **It can only execute UserOps
> based on zkProofs.**

Withdrawing ETH fees is a direct transfer of funds and is not a "UserOp based on
a zkProof." This violates the principle of least privilege by granting a
semi-trusted role a level of control over protocol funds that should be reserved
for the fully trusted owner.

## Internal Pre-conditions

N/A

## External Pre-conditions

N/A

## Attack Path

N/A

## Impact

Direct loss of gas fees.

## PoC

N/A
